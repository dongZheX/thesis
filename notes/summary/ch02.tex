\section{Numerical Solver}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Discretization}
\subsubsection{Spherical Coordinates}
Since the system has axial symmetry, the operators are written in 
spherical coordinates $(r,\theta,\phi)$:
\begin{eqnarray}
\brc{l}{
x = r \sin \theta \cos \phi \\
y = r \sin \theta \sin \phi \\
z = r \cos \theta} 
\end{eqnarray}
Due to axial symmetry, 
so the scalar gradient and the divergence can be written as:
\begin{eqnarray}
\bnabla f &=& \deriv{f}{r}\brhat + \frac{1}{r}\deriv{f}{\theta}\bthetahat \\
\bnabla \cdot \bF &=& \frac{1}{r^2}\deriv{}{r}\pars{F_r r^2 } + 
               \frac{1}{r \sin\theta}\deriv{}{\theta}\pars{F_\theta \sin\theta}
\end{eqnarray}
The scalar laplacian can be written as:
\begin{eqnarray}
\Laplacian f = \bnabla \cdot (\bnabla f)&=& 
 \frac{1}{r^2}\deriv{}{r}\pars{r^2 \deriv{f}{r}} + 
 \frac{1}{r^2 \sin\theta}\deriv{}{\theta}\pars{\sin\theta \deriv{f}{\theta}}
\end{eqnarray}
The vector gradient can be written as:
\begin{eqnarray}
\bnabla \bF &=& \deriv{F_r}{r} \brhat \brhat + \deriv{F_\theta}{r} \brhat \bthetahat + 
\frac{1}{r}\pars{\deriv{F_r}{\theta} - F_\theta} \bthetahat \brhat + 
\frac{1}{r}\pars{\deriv{F_\theta}{\theta} + F_r} \bthetahat \bthetahat
\end{eqnarray}

The vector laplacian can be written as:
\begin{eqnarray}
\bLaplacian \bF &=& 
\left(\Laplacian F_r - \frac{2F_r}{r^2} - 
\frac{2}{r^2 \sin\theta} \deriv{\left(F_\theta \sin\theta \right)}{\theta}\right)\brhat
+ \left(\Laplacian F_\theta - \frac{F_\theta}{r^2 \sin^2\theta} + 
\frac{2}{r^2}\deriv{F_r}{\theta}\right) \bthetahat
\end{eqnarray}

\subsubsection{Grids choice}
In order to discretize the differential operators, 
a regular grid of size $n_r \times n_\theta$ is used:
\begin{eqnarray}
(r_i,\theta_j) &\in& [1, \infty) \times [0,\pi] \\ 
r_i &=& (1+\Delta_r)^i \\
\theta_j &=& \Delta_\theta \cdot j
\end{eqnarray}
where a logarithmic grid is used for $r$ and an uniform one is used for $\theta$.
Note that $r_0 = 1$ and $R_{max} = (1+\Delta_r)^{n_r}$. Thus:
\begin{eqnarray}
\Delta_r &=& \pars{R_{max}} ^ \frac{1}{n_r} - 1 \\
\Delta_\theta &=& \frac{\pi}{n_\theta}
\end{eqnarray}

This grid induces disjoint subdivision of the domain 
$\Omega = [1, R_{max}] \times [0,\pi]$ into cells:
\begin{eqnarray}
\bigcup_{ij}\Omega_{ij} &=& \Omega
\end{eqnarray}
A specific cell $\Omega_{ij}$ and its center $(\bar{r}_i, \bar{\theta}_j)$ are defined by:
\begin{eqnarray}
\Omega_{ij} &=& [r_{i-1}, r_{i}] \times [\theta_{i-1}, \theta_{i}] \\
\bar{r}_i &=& \frac{r_{i-1} + r_{i}}{2} \\
\bar{\theta}_i &=& \frac{\theta_{i-1} + \theta_{i}}{2}
\end{eqnarray}

Each variable is discretized with respect of the cell:
\begin{itemize}
\item $\varPhi$, $C$ and $P$ are represented by their value at the center of each cell, 
using a central grid:
\begin{eqnarray}
\varPhi[i,j] &=& \varPhi(\bar{r}_i, \bar{\theta}_j) \\
C[i,j] &=& C(\bar{r}_i, \bar{\theta}_j) \\
P[i,j] &=& P(\bar{r}_i, \bar{\theta}_j) 
\end{eqnarray}
\item $\bV$ is represented by its values at cell boundaries, using a staggered grid:
\begin{eqnarray}
V_r[i,j] &=& V_r(r_i, \bar{\theta}_j) \\
V_\theta[i,j] &=& V_\theta(\bar{r}_i, {\theta}_j)
\end{eqnarray}
\end{itemize}

\subsubsection{Operator Discretization}
Finite-volume method with linear interpolation between grids is used for flux 
$\boldsymbol{f}$ discretization. 

Denote the following discrete central difference operators:
\begin{eqnarray}
\cD_r(f)[i,j] &=& \frac{f\left[i+\half,j\right] - f\left[i-\half,j\right]}
                       {r\left[i+\half,j\right] - r\left[i-\half,j\right]} \\
\cD_\theta(f)[i,j] &=& \frac{f\left[i,j+\half\right] - f\left[i,j-\half\right]}
					   {\theta\left[i,j+\half\right] - \theta\left[i,j-\half\right]}
\end{eqnarray}

Denote the following interpolation operators:
\begin{eqnarray}
\cI_r(f)[i,j] &=& \frac{
\pars{r\left[i,j\right] - r\left[i-\half,j\right]} 
  f\left[i+\half,j\right] + 
\pars{r\left[i+\half,j\right] - r\left[i,j\right]} 
  f\left[i-\half,j\right] 
}{r\left[i+\half,j\right] - r\left[i-\half,j\right]}
\\
\cI_\theta(f)[i,j] &=& 
\frac{
\pars{r\left[i,j\right] - r\left[i,j-\half\right]} 
  f\left[i,j+\half\right] + 
\pars{r\left[i,j+\half\right] - r\left[i,j\right]} 
  f\left[i,j-\half\right] 
}{r\left[i,j+\half\right] - r\left[i,j-\half\right]}
\end{eqnarray}

The total flux of a cell is equal to zero (due to conservation):
\begin{eqnarray}
\bnabla \cdot \boldsymbol{f} &=& 0 
\\
\frac{1}{r^2} \cD_r\pars{f_r r^2} + 
\frac{1}{r \sin\theta} \cD_\theta\pars{f_\theta \sin\theta} &=& 0 
\\
\cD_r\pars{f_r \cdot r^2 \sin\theta} + \cD_\theta\pars{f_\theta \cdot r \sin\theta} &=& 0 
\end{eqnarray}

Ion flux are discretized on grid cells' boundaries:
\begin{eqnarray}
I_r &=& -\cI_r(C) \cdot \cD_r(\varPhi) \\
I_\theta &=& -\cI_\theta(C) \cdot \frac{\cD_\theta(\varPhi)}{r} 
\end{eqnarray}

Salt flux are discretized on grid cells' boundaries 
(using upwind scheme $\mathcal{U}$ for numerical stability at large cell Peclet number):
\begin{eqnarray}
J_r &=& -\cD_r(C) + \alpha V_r \cdot \mathcal{U}^{\bV}_r (C) \\
J_\theta &=& -\frac{\cD_\theta(C)}{r} + \alpha V_\theta \cdot \mathcal{U}^{\bV}_\theta (C) \\
 \mathcal{U}^{\bV}_r(C)[i,j] &=& C\left[i-\frac{\sign(V_r)}{2}, j\right] \\
 \mathcal{U}^{\bV}_\theta(C)[i,j] &=& C\left[i, j-\frac{\sign(V_\theta)}{2}\right] 
\end{eqnarray}

Mass flux $\bV$ is discretized on grid cells boundaries, 
using velocity staggered grid.

Force components are discretized on velocity staggered grid, where
linear interpolation is used for Coulomb force.
\begin{eqnarray}
F_r &=& -\cD_r(P) 
          + \cL(V_r) - \frac{2}{r^2} V_r 
		  - \frac{2}{r^2 \sin\theta} \cI_r(\cD_\theta (V_\theta \sin\theta))
          + \cD_r(\varPhi) \cdot \cI_r(\cL(\varPhi)) \\
F_\theta &=& -\frac{\cD_\theta(P)}{r} 
		  + \cL(V_\theta) - \frac{F_\theta}{r^2 \sin^2\theta} 
		  + \frac{2}{r^2} \cI_\theta(\cD_\theta(F_r))
		  + \frac{\cD_\theta(\varPhi)}{r} \cdot \cI_\theta(\cL(\varPhi)) \\
\cL(f) &=& \frac{1}{r^2}\cD_r\pars{\cD_r(f) r^2} + 
\frac{1}{r^2 \sin\theta} \cD_\theta\pars{\cD_\theta(f) \cdot \sin\theta}
\end{eqnarray}


\subsubsection{Boundary Conditions}
In order to represent discretize problem boundary condtions, 
``ghost'' points method is used. 
Variable grid is extended to include points outside the domain's interior,
so the variables at the ``ghost'' points are set to satisfy 
the discretized boundary conditions, following the analysis below.

The boundary conditions at the ion-exchange boundary ($r=1$) are:
\begin{eqnarray}
\cI_r(\varPhi) &=& -\cI_r(\log C) \\
\cD_r(\varPhi) &=& \cD_r(\log C) \\
V_r &=& 0 \\
V_\theta &=& 4\log\pars{\frac{1 + \exp\left\{\cI_\theta(\zeta)/2\right\}}{2}} \cdot 
			\cD_\theta(\zeta) \\
  \zeta &=& - \log \gamma - \cI_r(\varPhi)
\end{eqnarray}
The equations are discretized by using ``ghost'' points, outside the interior of the domain:
\begin{eqnarray}
  \frac{\varPhi[0,j] + \varPhi[1,j]}{2} &=& 
	-\frac{\log C[0,j] + \log C[1,j]}{2} \\
  \frac{\varPhi[1,j] - \varPhi[0,j]}{\Delta r} &=& 
	\frac{\log C[1,j] - \log C[0,j]}{\Delta r} 
\end{eqnarray}
By adding and subtracting the equations, we have:
\begin{eqnarray}
\varPhi[0,j] &=& -\log\brcs{C[1,j]} \\
C[0,j] &=& \exp\brcs{-\varPhi[1,j]} \\
  \zeta[j] &=& \cV -\frac{\varPhi[0,j] + \varPhi[1,j]}{2} 
                     = -\log\gamma -\frac{\varPhi[0,j] + \varPhi[1,j]}{2}
\end{eqnarray}
The slipping conditions can be written by:
\begin{eqnarray}
V_r[0,j] &=& 0 \\
\frac{V_\theta[0,j] + V_\theta[1,j]}{2} &=& V_\theta[j] = 
4\log\pars{\frac{1 + \exp\left\{\frac{1}{2}\frac{\zeta[j] + \zeta[j+1]}{2}\right\}}{2}} 
\cdot \frac{\zeta[j+1] - \zeta[j]}{\bar{\theta}_{j+1} - \bar{\theta}_{j}} \\
  V_\theta[0,j] &=& 2 V_\theta[j] - V_\theta[1,j]
\end{eqnarray}

For $\theta = 0$ and $\theta = \pi$, the ``ghost'' points are defined by:
\begin{eqnarray} 
\brc{l}{
\varPhi[i, 0] = \varPhi[i, 1] \\
C[i, 0] = C[i, 1] \\
V_r[i, 0] = V_r[i, 1] \\
V_\theta[i, 0] = 0
} 
\brc{l}{
\varPhi[i, n_\theta+1] = \varPhi[i, n_\theta] \\
C[i, n_\theta+1] = C[i, n_\theta] \\
V_r[i, n_\theta+1] = V_r[i, n_\theta] \\
V_\theta[i, n_\theta+1] = 0
} 
\end{eqnarray}

Far away from the ion-exchange boundary ($r\rightarrow\infty$) are:
\begin{eqnarray}
\frac{\varPhi[n_r + 1, j] - \varPhi[n_r, j]}{\bar{r}_{n_r + 1} - \bar{r}_{n_r}} 
 & = & -\beta \cos\bar{\theta}_j \\
C[n_r + 1, j] & = & 1 \\
V_r[n_r + 1, j] & = & -\cU \cos\bar{\theta}_j \\
V_\theta[n_r + 1, j] & = & \cU \sin\theta_j
\end{eqnarray}
Since the actual grid is finite, $r_{n_r} = R_{max}$ will have an effect on the solution too.

Note that $P$ has no boundary conditions -- so the pressure variable is defined 
on the domain's interior.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solver Design}
\subsubsection{Newton Method}
An operator $\cO$ is defined by its input vector $\bx$ and its output 
$\by = \cO(\bx)$.

Using an algebra of operators, the composition of operators is well defined:
\begin{eqnarray}
(\cO_1 \circ \cO_2)(\bx) &=& \cO_1(\cO_2(\bx))
\end{eqnarray}
Note that the differentiation of composed operators is computed using chain rule:
\begin{eqnarray}
\bnabla(\cO_1 \circ \cO_2)(\bx) &=& \bnabla \cO_1(\cO_2(\bx)) \cdot \bnabla \cO_2(\bx)
\end{eqnarray}

Thus, in order to solve the equation $\cO(\bx) = \bzero$, a Newton step can 
be computed by:
\begin{eqnarray}
\bzero = \cO(\bx_n + \Delta \bx_n) &\approx& \cO(\bx_n) + \bnabla \cO(\bx_n)\cdot\Delta\bx_n \\
\bnabla \cO(\bx_n) \cdot \Delta \bx_n &=& -\cO(\bx_n) \\
\bx_{n+1} &=& \bx_{n} + \Delta \bx_n 
\end{eqnarray}

Therefore, in order to apply Newton method, the residual vector $\cO(\bx)$ and
the gradient matrix of the operator $\bnabla \cO(\bx)$ are to be computed.
Then, a sparse linear system is to be solved to yield current step vector $\Delta \bx$.

When the method converges $\bx_n \rightarrow \bx_\infty$, 
the convergence is quadratic:
\begin{eqnarray}
\|\bx_{n+1} - \bx_\infty\| \le \|\bx_{n} - \bx_\infty\|^2
\end{eqnarray}
Thus, when the initial guess is close enough to the solution, the solver
will converge in very few steps.


\subsubsection{Operator Representation}
System variable $\bx$ is defined as the concatenation $[\,\varPhi, C, V_r, V_\theta, P\,]$,
taking values in the interior of the problem domain grid.

Thus, each problem variable can be computed by applying an appropriate projection operator:
\begin{eqnarray}
X &=& \cP_X(\bx) \mbox{ for } X \in \left\{\varPhi, C, V_r, V_\theta, P\right\}
\end{eqnarray}

The extended variables $\tilde X$ (with ``ghost'' points values 
from boundary conditions) are be computed, by applying the following non-linear operators:
\begin{eqnarray}
\tilde{\varPhi} &=& \cB_\varPhi(\varPhi, C; \beta) \\
\tilde{C} &=& \cB_C(C, \varPhi) \\
\tilde{V_r} &=& \cB_{V_r}(V_r; \cU) \\
\tilde{V_\theta} &=& \cB_{V_\theta}(V_\theta, C, \varPhi; \cU, \gamma) \\
\tilde{P} &=& P
\end{eqnarray}

The concatenated equations of the system (as described above) can be written 
as a non-linear operator $\cE(\tilde\bx) = \bzero$ acting on the extended variables $\tilde\bx = \cB(\bx)$:
The problem can be casted as solving $\cO(\bx) = \bzero$ for $\cO = \cE \circ \cB$,
where $\cB$ is the ``ghost'' point extension operator (derived using boundary conditions) 
and $\cE$ is the conservation equations operator (derived by concatenation of the system
equations).

\subsubsection{Steady-state}
After convergence, the ``ghost'' points values are updated using $\cB$,
so the force $\tT \cdot \bn$ acting on the ion-exchanger surface
can be computed.

Due to symmetry considerations, the total force $\bF$ is 
aligned with $\ui$ and it vanishes iff $\ui \cdot \bF = 0$.
\begin{eqnarray}
F_\imath = \ui \cdot \bF &=& \oint_\mathcal{S} \ui \cdot \tT \cdot \bnhat  dA = 
\int_0^\pi f_\imath(\theta) \cdot 2\pi \sin\theta d\theta 
\\  
f_\imath &=& \imath \cdot \tT \cdot \bnhat
\\  
f_\imath &=& \pars{-P + 2\cD_r(V_r) + 
\frac{1}{2}\pars{\cD_r(\varPhi)}^2 - \frac{1}{2r^2}\pars{\cD_\theta(\varPhi)}^2}\cos\theta 
\\  
&& -\pars{\cD_r(V_\theta) - \frac{V_\theta}{r}
+ \frac{1}{r}\cD_r(\varPhi) \cD_{\theta}(\varPhi)}\sin\theta \\
 \mathcal{S} &=& \{\br : \|\br\|_2 = 1\}
\end{eqnarray}

The integral above is approximated by 1D numerical quadrature, to yield 
the total force $F_\imath$ as a function of the drift velocity $\cU$.

Since the goal is to find steady-state solution, $F_\imath(\cU)$ is required to be zero --
and the appropriate $\cU$ is found by 1D root-finding algorithm.

\subsubsection{Continuation}

System steady-state drift velocity $\cU(\beta)$ is computed as a function 
of the electric field magnitude for several values of $\beta$.
Since the solution $\bx_\infty$ is continous in $\beta$ and $\cU$, 
the result of the current iteration is used as an initial solution $\bx_0$ for the problem 
of the next iteration -- helping the convergence of the iterative solver in use.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Solver Implementation}

Object-Oriented Design methodology is used to for solver implementation.
MATLAB programming language is chosen due to strong numerical capabilities
and high-level language features.

\subsubsection{Operator Interface}
The base \verb|Operator| interface is defined by 
supporting the computation of a residual/result vector \verb|op.res()|
and a gradient matrix \verb|op.grad()|.
This interface is implemented in various operators classes,
which are used to constuct $\cO = \cE \circ \cB$ and to apply Newton method
to the problem by computing the residual and the gradient automatically.
Each such operator may be defined using other operators, so its residual
and gradient are computed recursively.

\subsubsection{Unary operators}
\paragraph{Linear operator}
If $\cO$ is linear, it can be represented by a matrix $L$, such that:
\begin{eqnarray}
\cO(\bx) &=& L \bx \\
\bnabla\cO &=& L 
\end{eqnarray}
Note that finite difference $\cD$, interpolation $\cI$ and 
upwind selection $\mathcal{U}$ operators
can be implemented as linear sparse operators, by constructing 
an appropriate sparse matrix $L$, having $O(\dim \bx)$ non-zeroes) 

\paragraph{Pointwise scalar function}
Let $f: \R \rightarrow \R$ be a differentiable 1D function, whose derivative is
denoted by $f': \R \rightarrow \R$. The operator $\cF$ can be defined to
represent pointwise application of $f$:
\begin{eqnarray}
\cF(\bx) &=& [f(x_1); \ldots; f(x_n)] \\
\bnabla\cF(\bx) &=& \diag(f'(x_1), \ldots, f'(x_n))
\end{eqnarray}
$f$ is defined and differentiated automatically using MATLAB symbolic toolbox.

\paragraph{Constant value}
A constant operator $\mathcal{C}$ is defined as having constant vector value $\bc$ 
(that does not depend on $\bx$):
\begin{eqnarray}
\mathcal{C}(\bx) &=& \bc \\
\bnabla\mathcal{C} &=& \bzero
\end{eqnarray}

\subsubsection{Binary operators}
Let $\cO_1$ and $\cO_2$ be two operators, so their pointwise addition, subtraction
and multiplication are defined as follows:
\begin{eqnarray}
(\cO_1 \pm \cO_2)(\bx) &=& \cO_1)(\bx) \pm \cO_2(\bx) \\
\bnabla (\cO_1 \pm \cO_2)(\bx)   &=& \bnabla\cO_1(\bx) \pm \bnabla\cO_2(\bx) \\
(\cO_1 \cdot \cO_2)(\bx) &=& \diag(\diag(\cO_1(\bx)) \cdot \diag(\cO_2(\bx))) \\
\bnabla (\cO_1 \cdot \cO_2)(\bx) &=& \diag(\cO_2(\bx)) \bnabla\cO_1(\bx) 
                                  + \diag(\cO_1(\bx)) \bnabla\cO_2(\bx)
\end{eqnarray}

\subsubsection{N-ary operators}
Given $N$ operators $\{\cO_i\}_{i=1}^N$, their concatenation $\cO$ is defined as:
\begin{eqnarray}
\cO(\bx) &=& [\cO_1(\bx); \ldots; \cO_N(\bx)] \\
(\bnabla\cO)(\bx) &=& [(\bnabla\cO_1)(\bx); \ldots; (\bnabla\cO_N)(\bx)]
\end{eqnarray}

\subsubsection{Iterative Newton solver}
Given an initial solution $\bx_0$, we apply the following algorithm 
until convergence ($\|\Delta \bx\| < \eps$):
\begin{enumerate}
\item Update the system: $\verb|op| = \verb|System|(\bx_{n})$
\item Compute the gradient: $\boldsymbol{A}_n = \verb|op.grad()|$
\item Compute the right-hand side: $\boldsymbol{b}_n = \verb|-op.res()|$
\item Solve sparse linear system: $\boldsymbol{A}_n \Delta \bx_n = \boldsymbol{b}_n$
\item Update solution: $\bx_{n+1} = \bx_{n} + \Delta \bx_{n}$
\end{enumerate}

\subsubsection{Total force integration -- $F_\imath$}
After the solver converges ($\bx_n \rightarrow \bx_\infty$), 
the ``ghost'' points values are computed by applying $\cB$ and
solving for zero force  $\brhat$ component on $r=1$ boundary

$F_\imath$ is computed using mid-point quadrature method:
\begin{eqnarray}
F_\imath &=& \sum_{i=1}^{n_\theta} f(\bar\theta_i) \cdot 
              2 \pi \sin\bar\theta_i \cdot (\theta_i - \theta_{i-1})
\end{eqnarray}

\subsubsection{Steady state drift velocity -- $\cU$}
In steady state, the force acting on the particle $F_\imath$ shoud vanish.
This yields an equation on $\cU$:
\begin{eqnarray}
F_\imath(\cU) &=& 0
\end{eqnarray}
This equation can be solved using 1D root finding algorithm, e.g. Secant method:
\begin{eqnarray}
\cU_{n+1} = \frac{F_\imath(\cU_{n})\cU_{n-1} - F_\imath(\cU_{n-1})\cU_{n}}
{F_\imath(\cU_{n}) - F_\imath(\cU_{n-1})} \rightarrow \cU_\infty
\end{eqnarray}
The result $\cU_\infty$ is the 
steady state particle drift velocity for the electric field $\beta$.

