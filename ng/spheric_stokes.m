function A = spheric_stokes(gridVx, gridVy, gridP)

[Gp_x, Lv_x0, Dv_x] = stokes1(1, gridVx, gridP);
[Gp_y, Lv_y0, Dv_y] = stokes1(2, gridVy, gridP);

I = find(gridVx.I);
% -2Vr / r^2
Lv_x1 = -2*sparse(1:numel(I), I, ...
    1./gridVx.X(I).^2, numel(I), prod(gridVx.sz));

Lv_x2 = 2*sparse(1:numel(I), 1:numel(I), ...
    1./( sin(gridVx.Y(I)) .* gridVx.X(I).^2 )) * ...
    interpolator(average(gridVy.X, [1, 1]/2), gridVx.X(2:end-1, 2:end-1)) * ...
    deriv(gridVy.Y, [0 1]) * ...
    sparse(1:prod(gridVy.sz), 1:prod(gridVy.sz), sin(gridVy.Y));

I = find(gridVy.I);
% -Vtheta/(r * sin theta)^2
Lv_y1 = -sparse(1:numel(I), I, ...
    1./( gridVy.X(I) .* sin(gridVy.Y(I)) ).^2, numel(I), prod(gridVy.sz));

Lv_y2 = 2*sparse(1:numel(I), 1:numel(I), gridVy.X(I).^(-2)) * ...
    interpolator(average(gridVx.X, [1 1]/2), gridVy.X(2:end-1, 2:end-1)) * ...
    deriv(gridVx.Y, [0 1]);

Z = sparse(prod(gridP.sz), prod(gridP.sz));

A = [Lv_x0 + Lv_x1, Lv_x2,         Gp_x; ...
    Lv_y2,          Lv_y0 + Lv_y1, Gp_y; ...
    Dv_x,           Dv_y,          Z];

